// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: track.sql

package storage

import (
	"context"
	"time"

	"github.com/gofrs/uuid"
	null "gopkg.in/guregu/null.v4"
	"musicd/internal/track/domain"
)

const createTrack = `-- name: CreateTrack :exec
insert into "track" (id, title, duration, files, uploaded_by, uploaded_at)
values ($1, $2, $3, $4, $5, $6)
`

type CreateTrackParams struct {
	ID         uuid.UUID
	Title      string
	Duration   null.Int
	Files      domain.Files
	UploadedBy uuid.UUID
	UploadedAt time.Time
}

func (q *Queries) CreateTrack(ctx context.Context, arg CreateTrackParams) error {
	_, err := q.db.Exec(ctx, createTrack,
		arg.ID,
		arg.Title,
		arg.Duration,
		arg.Files,
		arg.UploadedBy,
		arg.UploadedAt,
	)
	return err
}

const findTracks = `-- name: FindTracks :many
select id, artist_id, album_id, title, duration, files, uploaded_by, uploaded_at from "track" t
where t.id = ANY ($1::uuid[])
`

func (q *Queries) FindTracks(ctx context.Context, trackIds []uuid.UUID) ([]Track, error) {
	rows, err := q.db.Query(ctx, findTracks, trackIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.ArtistID,
			&i.AlbumID,
			&i.Title,
			&i.Duration,
			&i.Files,
			&i.UploadedBy,
			&i.UploadedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginateTracks = `-- name: PaginateTracks :many
select id, artist_id, album_id, title, duration, files, uploaded_by, uploaded_at
from "track"
where $1::timestamp is null
   or uploaded_at < $1
   or ($2::uuid is null or (uploaded_at = $1 and id > $2))
order by uploaded_at desc, id
limit $3
`

type PaginateTracksParams struct {
	AfterUploadedAt null.Time
	AfterID         uuid.NullUUID
	First           int32
}

func (q *Queries) PaginateTracks(ctx context.Context, arg PaginateTracksParams) ([]Track, error) {
	rows, err := q.db.Query(ctx, paginateTracks, arg.AfterUploadedAt, arg.AfterID, arg.First)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.ArtistID,
			&i.AlbumID,
			&i.Title,
			&i.Duration,
			&i.Files,
			&i.UploadedBy,
			&i.UploadedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
